{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 82, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/USER/Desktop/SIPPesantren/5c545958-637b-416e-a3eb-5dcf940bcaca/src/db/index.ts"],"sourcesContent":["import { google } from 'googleapis';\r\n\r\n// Google Sheets configuration\r\nconst auth = new google.auth.GoogleAuth({\r\n  credentials: {\r\n    client_email: process.env.GOOGLE_SHEETS_CLIENT_EMAIL,\r\n    private_key: process.env.GOOGLE_SHEETS_PRIVATE_KEY?.replace(/\\\\n/g, '\\n'),\r\n  },\r\n  scopes: ['https://www.googleapis.com/auth/spreadsheets'],\r\n});\r\n\r\nconst sheets = google.sheets({ version: 'v4', auth });\r\n\r\n// Cache for sheet names to reduce API calls\r\nconst sheetNameCache: { [key: string]: { name: string; timestamp: number } } = {};\r\nconst CACHE_TTL = 5 * 60 * 1000; // 5 minutes\r\n\r\n// Rate limiting and retry configuration\r\nconst REQUEST_QUEUE: (() => Promise<void>)[] = [];\r\nlet lastRequestTime = 0;\r\nconst MIN_REQUEST_INTERVAL = 300; // 300ms between requests (~3.3 requests per second)\r\nconst MAX_RETRIES = 3;\r\nconst INITIAL_RETRY_DELAY = 1000; // 1 second\r\n\r\n// In-memory data cache\r\nconst dataCache: { [key: string]: { data: any[]; timestamp: number } } = {};\r\nconst DATA_CACHE_TTL = 30 * 1000; // 30 seconds cache for read operations\r\n\r\n// Process request queue with retry logic\r\nasync function processQueue() {\r\n  if (REQUEST_QUEUE.length === 0) return;\r\n  \r\n  const now = Date.now();\r\n  const timeSinceLastRequest = now - lastRequestTime;\r\n  \r\n  if (timeSinceLastRequest < MIN_REQUEST_INTERVAL) {\r\n    setTimeout(processQueue, MIN_REQUEST_INTERVAL - timeSinceLastRequest);\r\n    return;\r\n  }\r\n  \r\n  const request = REQUEST_QUEUE.shift();\r\n  if (request) {\r\n    lastRequestTime = Date.now();\r\n    try {\r\n      await request();\r\n    } catch (error) {\r\n      console.error('Request failed:', error);\r\n    }\r\n    // Process next request\r\n    setTimeout(processQueue, MIN_REQUEST_INTERVAL);\r\n  }\r\n}\r\n\r\n// Execute request with retry logic for 429 errors\r\nasync function executeWithRetry<T>(fn: () => Promise<T>, retries = MAX_RETRIES, delay = INITIAL_RETRY_DELAY): Promise<T> {\r\n  try {\r\n    return await fn();\r\n  } catch (error: any) {\r\n    // Check if it's a quota exceeded error (429)\r\n    if (error?.code === 429 || error?.status === 429 || error?.message?.includes('Quota exceeded')) {\r\n      if (retries > 0) {\r\n        console.log(`Quota exceeded, retrying in ${delay}ms... (${retries} retries left)`);\r\n        await new Promise(resolve => setTimeout(resolve, delay));\r\n        return executeWithRetry(fn, retries - 1, delay * 2); // Exponential backoff\r\n      }\r\n    }\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Add request to queue with retry support\r\nfunction queueRequest<T>(fn: () => Promise<T>): Promise<T> {\r\n  return new Promise((resolve, reject) => {\r\n    REQUEST_QUEUE.push(async () => {\r\n      try {\r\n        const result = await executeWithRetry(fn);\r\n        resolve(result);\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n    processQueue();\r\n  });\r\n}\r\n\r\n// Get cached data if available\r\nfunction getCachedData(key: string): any[] | null {\r\n  const cached = dataCache[key];\r\n  if (cached && (Date.now() - cached.timestamp) < DATA_CACHE_TTL) {\r\n    return cached.data;\r\n  }\r\n  return null;\r\n}\r\n\r\n// Set cached data\r\nfunction setCachedData(key: string, data: any[]) {\r\n  dataCache[key] = { data, timestamp: Date.now() };\r\n}\r\n\r\n// Clear cached data for a key\r\nfunction clearCachedData(key: string) {\r\n  delete dataCache[key];\r\n}\r\n\r\n// Sheet configurations\r\nconst sheetConfigs = {\r\n  santris: {\r\n    id: process.env.SHEET_ID_SANTRI,\r\n    gid: '0',\r\n    range: 'Sheet1!A:Z',\r\n  },\r\n  ustadzs: {\r\n    id: process.env.SHEET_ID_USTADZ,\r\n    gid: '189830710',\r\n    range: 'Sheet1!A:Z',\r\n  },\r\n  absensis: {\r\n    id: process.env.SHEET_ID_ABSENSI,\r\n    gid: '95055288',\r\n    range: 'Sheet1!A:Z',\r\n  },\r\n  transaksis: {\r\n    id: process.env.SHEET_ID_TRANSAKSI,\r\n    gid: '191644107',\r\n    range: 'Sheet1!A:Z',\r\n  },\r\n  pelanggarans: {\r\n    id: process.env.SHEET_ID_PELANGGARAN,\r\n    gid: '1684122507',\r\n    range: 'Sheet1!A:Z',\r\n  },\r\n  setoranHafalans: {\r\n    id: process.env.SHEET_ID_HAFALAN,\r\n    gid: '869009823',\r\n    range: 'Sheet1!A:Z',\r\n  },\r\n  orangTua: {\r\n    id: process.env.SHEET_ID_ORANG_TUA,\r\n    gid: '0',\r\n    range: 'Sheet1!A:Z',\r\n  },\r\n  users: {\r\n    id: process.env.SHEET_ID_USERS,\r\n    gid: '0',\r\n    range: 'Sheet1!A:Z',\r\n  }\r\n};\r\n\r\n// Helper function to get sheet config\r\nfunction getSheetConfig(tableName: string) {\r\n  return sheetConfigs[tableName as keyof typeof sheetConfigs];\r\n}\r\n\r\n// Helper function to get actual sheet name with caching\r\nasync function getActualSheetName(tableName: string): Promise<string> {\r\n  const config = getSheetConfig(tableName);\r\n  if (!config || !config.id) return 'Sheet1';\r\n  \r\n  // Check cache first with TTL\r\n  const cached = sheetNameCache[config.id];\r\n  if (cached && (Date.now() - cached.timestamp) < CACHE_TTL) {\r\n    return cached.name;\r\n  }\r\n  \r\n  try {\r\n    const spreadsheet = await queueRequest(() => sheets.spreadsheets.get({\r\n      spreadsheetId: config.id,\r\n    }));\r\n    \r\n    const sheetNames = spreadsheet.data.sheets?.map(s => s.properties?.title).filter((t): t is string => !!t) || [];\r\n    const actualSheetName = sheetNames[0] || 'Sheet1';\r\n    \r\n    // Cache the result with timestamp\r\n    if (config.id) {\r\n      sheetNameCache[config.id] = { name: actualSheetName, timestamp: Date.now() };\r\n    }\r\n    \r\n    return actualSheetName;\r\n  } catch (error) {\r\n    console.error(`Error getting sheet name for ${tableName}:`, error);\r\n    return 'Sheet1';\r\n  }\r\n}\r\n\r\n// Helper function to find row index by ID\r\nfunction findRowIndexById(allData: any[], id: number | string): number {\r\n  const targetId = Number(id);\r\n  \r\n  for (let i = 0; i < allData.length; i++) {\r\n    const rowId = allData[i].id;\r\n    if (rowId === null || rowId === undefined) continue;\r\n    \r\n    const parsedRowId = Number(rowId);\r\n    if (parsedRowId === targetId) {\r\n      return i;\r\n    }\r\n  }\r\n  \r\n  return -1;\r\n}\r\n\r\nasync function fetchSheetData(sheetName: string): Promise<any[]> {\r\n  try {\r\n    // Check cache first\r\n    const cached = getCachedData(sheetName);\r\n    if (cached) {\r\n      return cached;\r\n    }\r\n\r\n    const config = getSheetConfig(sheetName);\r\n    if (!config || !config.id) {\r\n      console.error(`Sheet config not found for ${sheetName}`);\r\n      return [];\r\n    }\r\n\r\n    // Use cached sheet name to reduce API calls\r\n    const actualSheetName = await getActualSheetName(sheetName);\r\n    const range = `${actualSheetName}!A:Z`;\r\n\r\n    const response = await queueRequest(() => sheets.spreadsheets.values.get({\r\n      spreadsheetId: config.id,\r\n      range: range,\r\n    }));\r\n\r\n    const rows = response.data.values;\r\n    if (!rows || rows.length === 0) {\r\n      return [];\r\n    }\r\n\r\n    // Convert rows to objects using headers\r\n    const headers = rows[0];\r\n    const data = rows.slice(1).map(row => {\r\n      const obj: any = {};\r\n      headers.forEach((header: string, index: number) => {\r\n        obj[header] = row[index] || null;\r\n      });\r\n      return obj;\r\n    });\r\n\r\n    // Cache the data\r\n    setCachedData(sheetName, data);\r\n    return data;\r\n  } catch (error) {\r\n    console.error(`Error fetching ${sheetName} data:`, error);\r\n    return [];\r\n  }\r\n}\r\n\r\n// Export database interface\r\nexport const db: {\r\n  select: (tableName: string) => Promise<any[]>;\r\n  insert: (tableName: string, data: any) => Promise<{ success: boolean }>;\r\n  update: (tableName: string, id: number | string, data: any) => Promise<{ success: boolean }>;\r\n  delete: (tableName: string, id: number | string) => Promise<{ success: boolean }>;\r\n} = {\r\n  select: async (tableName: string): Promise<any[]> => {\r\n    return await fetchSheetData(tableName);\r\n  },\r\n  \r\n  insert: async (tableName: string, data: any): Promise<{ success: boolean }> => {\r\n    try {\r\n      const config = getSheetConfig(tableName);\r\n      if (!config) {\r\n        throw new Error(`Sheet config not found for ${tableName}`);\r\n      }\r\n\r\n      const sheetName = await getActualSheetName(tableName);\r\n      \r\n      // Get headers from first row\r\n      const headerResponse = await queueRequest(() => sheets.spreadsheets.values.get({\r\n        spreadsheetId: config.id,\r\n        range: `${sheetName}!A1:Z1`,\r\n      }));\r\n\r\n      const headers = headerResponse.data.values?.[0] || [];\r\n      \r\n      // Build values array in the same order as headers\r\n      const values = headers.map((header: string) => {\r\n        const value = data[header] ?? '';\r\n        return value;\r\n      });\r\n      \r\n      // Append to sheet\r\n      await queueRequest(() => sheets.spreadsheets.values.append({\r\n        spreadsheetId: config.id,\r\n        range: `${sheetName}!A:Z`,\r\n        valueInputOption: 'RAW',\r\n        requestBody: {\r\n          values: [values],\r\n        },\r\n      }));\r\n\r\n      // Clear cache after write\r\n      clearCachedData(tableName);\r\n      \r\n      console.log(`Inserted into ${tableName}:`, data);\r\n      return { success: true };\r\n    } catch (error) {\r\n      console.error(`Error inserting into ${tableName}:`, error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  \r\n  update: async (tableName: string, id: number | string, data: any): Promise<{ success: boolean }> => {\r\n    try {\r\n      const config = getSheetConfig(tableName);\r\n      if (!config) {\r\n        throw new Error(`Sheet config not found for ${tableName}`);\r\n      }\r\n\r\n      const sheetName = await getActualSheetName(tableName);\r\n      \r\n      // Get all data to find the row\r\n      const allData = await fetchSheetData(tableName);\r\n      \r\n      // Find row index\r\n      const rowIndex = findRowIndexById(allData, id);\r\n      \r\n      if (rowIndex === -1) {\r\n        throw new Error(`Record with id ${id} not found in ${tableName}`);\r\n      }\r\n      \r\n      // Get headers from first row\r\n      const spreadsheet = await queueRequest(() => sheets.spreadsheets.values.get({\r\n        spreadsheetId: config.id,\r\n        range: `${sheetName}!A1:Z1`,\r\n      }));\r\n\r\n      const headers = spreadsheet.data.values?.[0] || [];\r\n      \r\n      // Build update values array\r\n      const targetId = Number(id);\r\n      const updateValues = headers.map((header: string) => {\r\n        let value;\r\n        if (header === 'id') value = targetId;\r\n        else if (header === 'updatedAt') value = new Date().toISOString();\r\n        else value = data[header] ?? '';\r\n        return value;\r\n      });\r\n      \r\n      // Update the row (rowIndex + 2 because row 1 is headers, and arrays are 0-indexed)\r\n      const updateRange = `${sheetName}!A${rowIndex + 2}:Z${rowIndex + 2}`;\r\n      \r\n      await queueRequest(() => sheets.spreadsheets.values.update({\r\n        spreadsheetId: config.id,\r\n        range: updateRange,\r\n        valueInputOption: 'RAW',\r\n        requestBody: {\r\n          values: [updateValues],\r\n        },\r\n      }));\r\n\r\n      // Clear cache after write\r\n      clearCachedData(tableName);\r\n      \r\n      console.log(`Updated ${tableName} with id ${id}`);\r\n      return { success: true };\r\n    } catch (error) {\r\n      console.error(`Error updating ${tableName}:`, error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  \r\n  delete: async (tableName: string, id: number | string): Promise<{ success: boolean }> => {\r\n    try {\r\n      const config = getSheetConfig(tableName);\r\n      if (!config) {\r\n        throw new Error(`Sheet config not found for ${tableName}`);\r\n      }\r\n\r\n      const sheetName = await getActualSheetName(tableName);\r\n      \r\n      // Get all data to find the row\r\n      const allData = await fetchSheetData(tableName);\r\n      \r\n      // Find row index\r\n      const rowIndex = findRowIndexById(allData, id);\r\n      \r\n      if (rowIndex === -1) {\r\n        throw new Error(`Record with id ${id} not found in ${tableName}`);\r\n      }\r\n      \r\n      // Clear the row (rowIndex + 2 because row 1 is headers)\r\n      await queueRequest(() => sheets.spreadsheets.values.clear({\r\n        spreadsheetId: config.id,\r\n        range: `${sheetName}!A${rowIndex + 2}:Z${rowIndex + 2}`,\r\n      }));\r\n\r\n      // Clear cache after write\r\n      clearCachedData(tableName);\r\n      \r\n      console.log(`Deleted from ${tableName} with id ${id}`);\r\n      return { success: true };\r\n    } catch (error) {\r\n      console.error(`Error deleting from ${tableName}:`, error);\r\n      throw error;\r\n    }\r\n  },\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 443, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/USER/Desktop/SIPPesantren/5c545958-637b-416e-a3eb-5dcf940bcaca/src/app/ustadz/absensi/actions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { db } from \"@/db\";\r\nimport { revalidatePath } from \"next/cache\";\r\n\r\nexport async function createAbsensi(data: {\r\n  SantriId: number;\r\n  ustadzId: number;\r\n  tanggal: string;\r\n  status: string;\r\n  keterangan?: string;\r\n}) {\r\n  try {\r\n    // Generate new ID\r\n    const allData = await db.select(\"absensis\");\r\n    const newId = allData.length > 0 \r\n      ? Math.max(...allData.map((d: any) => parseInt(d.id) || 0)) + 1 \r\n      : 1;\r\n\r\n    await db.insert(\"absensis\", {\r\n      id: newId,\r\n      ...data,\r\n      createdAt: new Date().toISOString(),\r\n    });\r\n\r\n    revalidatePath(\"/ustadz/absensi\");\r\n    return { success: true };\r\n  } catch (error) {\r\n    console.error(\"Error creating absensi:\", error);\r\n    throw new Error(\"Failed to create absensi\");\r\n  }\r\n}\r\n\r\nexport async function updateAbsensi(\r\n  id: number,\r\n  data: {\r\n    SantriId?: number;\r\n    ustadzId?: number;\r\n    tanggal?: string;\r\n    status?: string;\r\n    keterangan?: string;\r\n  }\r\n) {\r\n  try {\r\n    await db.update(\"absensis\", id, data);\r\n    revalidatePath(\"/ustadz/absensi\");\r\n    return { success: true };\r\n  } catch (error) {\r\n    console.error(\"Error updating absensi:\", error);\r\n    throw new Error(\"Failed to update absensi\");\r\n  }\r\n}\r\n\r\nexport async function deleteAbsensi(id: number) {\r\n  try {\r\n    await db.delete(\"absensis\", id);\r\n    revalidatePath(\"/ustadz/absensi\");\r\n    return { success: true };\r\n  } catch (error) {\r\n    console.error(\"Error deleting absensi:\", error);\r\n    throw new Error(\"Failed to delete absensi\");\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;AAEA;AACA;;;;;AAEO,eAAe,cAAc,IAMnC;IACC,IAAI;QACF,kBAAkB;QAClB,MAAM,UAAU,MAAM,wHAAE,CAAC,MAAM,CAAC;QAChC,MAAM,QAAQ,QAAQ,MAAM,GAAG,IAC3B,KAAK,GAAG,IAAI,QAAQ,GAAG,CAAC,CAAC,IAAW,SAAS,EAAE,EAAE,KAAK,MAAM,IAC5D;QAEJ,MAAM,wHAAE,CAAC,MAAM,CAAC,YAAY;YAC1B,IAAI;YACJ,GAAG,IAAI;YACP,WAAW,IAAI,OAAO,WAAW;QACnC;QAEA,IAAA,+IAAc,EAAC;QACf,OAAO;YAAE,SAAS;QAAK;IACzB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,2BAA2B;QACzC,MAAM,IAAI,MAAM;IAClB;AACF;AAEO,eAAe,cACpB,EAAU,EACV,IAMC;IAED,IAAI;QACF,MAAM,wHAAE,CAAC,MAAM,CAAC,YAAY,IAAI;QAChC,IAAA,+IAAc,EAAC;QACf,OAAO;YAAE,SAAS;QAAK;IACzB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,2BAA2B;QACzC,MAAM,IAAI,MAAM;IAClB;AACF;AAEO,eAAe,cAAc,EAAU;IAC5C,IAAI;QACF,MAAM,wHAAE,CAAC,MAAM,CAAC,YAAY;QAC5B,IAAA,+IAAc,EAAC;QACf,OAAO;YAAE,SAAS;QAAK;IACzB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,2BAA2B;QACzC,MAAM,IAAI,MAAM;IAClB;AACF;;;IAzDsB;IA4BA;IAoBA;;AAhDA,+OAAA;AA4BA,+OAAA;AAoBA,+OAAA"}},
    {"offset": {"line": 514, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/USER/Desktop/SIPPesantren/5c545958-637b-416e-a3eb-5dcf940bcaca/.next-internal/server/app/ustadz/absensi/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {createAbsensi as '4077296589ca4f3ce2dfedb8c7f2d8fdadc5adc7d6'} from 'ACTIONS_MODULE0'\nexport {updateAbsensi as '608a8e100afddb968650bc0ad91f53b536de631dc7'} from 'ACTIONS_MODULE0'\nexport {deleteAbsensi as '407409818b00f3061cb6b438f60454cf22dd50ba8b'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA"}}]
}